PART 1 - SETUP
1. CLI: django-admin startproject polling_site
2. pyenv local 3.12.0
3. cd polling_site, create venv
4. pip install django
5. python manage.py runserver
  - ignore migration warngings, follow URL
  - `runserver` automatically reloads for code changes, but not always for file additions
  - don't use this server for production only development
6. CLI: python manage.py startapp polls
  - New directory `polls` created with nested `migrations` dir and .py files
WRITE FIRST VIEW
7. Open polls/views.py and add code to create first view
8. To call the view, we need to map it to a URL - and for this we need a URLconf.
  - touch polls/urls.py and add code
9. The next step is to point the root URLconf at the polls.urls module. In mysite/urls.py, add an import for django.urls.include and insert an include() in the urlpatterns list
  - The include() function allows referencing other URLconfs. Whenever Django encounters include(), it chops off whatever part of the URL matched up to that point and sends the remaining string to the included URLconf for further processing.
  - The idea behind include() is to make it easy to plug-and-play URLs. Since polls are in their own URLconf (polls/urls.py), they can be placed under “/polls/”, or under “/fun_polls/”, or under “/content/polls/”, or any other path root, and the app will still work.
10. Try it out - visit http://localhost:8000/polls and run `python manage.py runserver`

PART 2 - DATABASE
11. Open polling_site/settings.py - SQLite is default, no need for installs. 
12. If you wish to use another database, install the appropriate database bindings and change the following keys in the DATABASES 'default' item to match your database connection settings:

    - ENGINE – Either 'django.db.backends.sqlite3', 'django.db.backends.postgresql', 'django.db.backends.mysql', or 'django.db.backends.oracle'. Other backends are also available.
    - NAME – The name of your database. If you’re using SQLite, the database will be a file on your computer; in that case, NAME should be the full absolute path, including filename, of that file. The default value, BASE_DIR / 'db.sqlite3', will store the file in your project directory.
  - If you are not using SQLite as your database, additional settings such as USER, PASSWORD, and HOST must be added. For more details, see the reference documentation for DATABASES.

13. Update TIME_ZONE = 'UTC-07:00'
14. CLI: python manage.py migrate
15. Create database table models - polls/models.py
16. Add "polls.apps.PollsConfig" to INSTALLED_APPS list in polling_site/settings.py. 
17. CLI: python manage.py makemigrations polls
18. (CLI: python manage.py check == checks for problems in project without making migrations or touching DB)
19. CLI: python manage.py migrate
SEQUENCE FOR DB MODEL CHANGES: 
- Change your models (in models.py).
- CLI: python manage.py makemigrations, to create migrations for those changes
- CLI: python manage.py migrate, to apply those changes to the database.

PART 3 - PLAYING WITH THE API
20. Invoke free Django API in Python shell - CLI: python manage.py shell (We’re using this instead of simply typing “python”, because manage.py sets the DJANGO_SETTINGS_MODULE environment variable, which gives Django the Python import path to your mysite/settings.py file.)
21. Django provides a rich database lookup API that's entirely driven by keyword arguments: 
>>> Question.objects.filter(id=1)
>>> Question.objects.filter(question_text__startswith="What")
# Request an ID that doesn't exist, this will raise an exception.
>>> Question.objects.get(id=2)
  Traceback (most recent call last):
    ...
  DoesNotExist: Question matching query does not exist.
And other stuff. Look up Django db API when time comes
https://docs.djangoproject.com/en/5.0/intro/tutorial02/#:~:text=py%20shell%20again%3A-,%3E%3E%3E%20from%20polls.models%20import%20Choice%2C%20Question,-%23%20Make%20sure%20our

PART 4 - DJANGO admin
1. Create an admin user - CLI: python manage.py createsuperuser (enter username, email, password)
2. Run server and visit page with "/admin" endpoint: python manage.py runserver
3. Make the poll app modifiable to the admin- 
polls/admin.py:
from django.contrib import admin
from .models import Question
admin.site.register(Question)
4. Refresh page to be able to edit Questions

PART 5 - VIEWS (Part 3 in documentation)
1. Add views to polls/views.py
2. Wire these new views into polls/urls.py
3. Create HTML templates - mkdir polls/templates
4. HTML templates are served with render(request, "route", template_vars_dict)
5. Add namespace to URLconf - in polls/urls.py add: app_name = "polls"
6. Links in html can be configured: 
  {% url 'app_name:route_name' param %} -> {% url 'polls:detail' question.id %}

PART 6 - FORMS (Part 4 in documentation)
1. Django comes with cross site request forgeries security, so within a form simply enter: {% csrf_token %}
2. From view function, request.POST['name']

PART 7 - GENERIC VIEWS - This part is confusing, so look at the docs.
1. Convert the URLconf: 
  - in polls/urls.py, change view arguments to `views.DetailView.as_view()` etc.
  - also updated urlParams to become 'pk' instead of 'question_id'
2. Amend views - each now becomes a class 
  - https://docs.djangoproject.com/en/5.0/intro/tutorial04/#:~:text=Each%20generic%20view,views%20documentation
  - https://docs.djangoproject.com/en/5.0/topics/class-based-views/
  - https://www.youtube.com/watch?v=RE0HlKch_3U

PART 8 - TESTING (Part 5 in documentation)
1. polls/tests.py - write test for recently published questions bug
2. To run tests, CLI: python manage.py test polls
  - manage.py test polls looked for tests in the polls application
  - it found a subclass of the django.test.TestCase class
  - it created a special database for the purpose of testing
  - it looked for test methods - ones whose names begin with test
  - in test_was_published_recently_with_future_question it created a Question instance whose pub_date field is 30 days in the future
  - … and using the assertIs() method, it discovered that its was_published_recently() returns True, though we wanted it to return False
  - The test informs us which test failed and even the line on which the failure occurred.
3. Test a view: 
